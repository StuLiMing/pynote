Python的`copy`库提供了通用的浅拷贝（shallow copy）和深拷贝（deep copy）操作。这个库对于处理复杂的数据结构（如列表、字典、自定义对象等）时，实现对象的复制非常有用，特别是当你需要复制的对象包含了对其他对象的引用时。

### 浅拷贝（Shallow Copy）

浅拷贝创建一个新对象，但它不会递归地复制对象中引用的其他对象，而是复制这些引用本身。这意味着，如果原始对象中的某个成员是对另一个对象的引用，那么在浅拷贝版本中，这个成员仍然指向同一个对象。因此，修改这个被引用的对象将会影响到原始对象和它的浅拷贝版本。

在`copy`库中，可以使用`copy()`函数来执行浅拷贝操作：

```python
import copy
obj_copy = copy.copy(original_obj)
```

### 深拷贝（Deep Copy）

深拷贝创建一个新对象，然后递归地复制原始对象中引用的所有对象。这意味着，如果原始对象包含了对其他对象的引用，深拷贝不仅会复制原始对象本身，还会复制所有被引用的对象及其链条上的对象。因此，原始对象和它的深拷贝版本在结构上完全独立，修改任何一个对象的成员都不会影响到另一个。

在`copy`库中，可以使用`deepcopy()`函数来执行深拷贝操作：

```python
import copy
obj_deepcopy = copy.deepcopy(original_obj)
```

### 例子

```python
import copy

a=[1,2,3]
b=[4,5,6]
c=[7,8,9]
L1=[a,b,c]

def initial():
    global a,b,c,L1
    a=[1,2,3]
    b=[4,5,6]
    c=[7,8,9]
    L1=[a,b,c]

# L2=L1，L2和L1指向同一个对象，二者是同一对象的两个不同名字
L2=L1
L1.append([0,0,0])
print("L2:",L2)


# L3=L1.copy()，创建一个新的对象，这个对象是 L1 的拷贝，L3 指向这个新对象
initial()
L3=L1.copy()
L1.append([0,0,0])
print("L3:",L3)
# a 是对一个对象的引用
a.append(4)
print("L3:",L3)

# copy.copy() 与 L1.copy() 效果相同
initial()
L4=copy.copy(L1)
L1.append([0,0,0])
print("L4:",L4)
a.append(4)
print("L4:",L4)

# copy.deepcopy(L1) 会递归地为 L1 中所有对象创建新的副本。原始对象和它的深拷贝版本在结构上完全独立，修改任何一个对象的成员都不会影响到另一个。
initial()
L5=copy.deepcopy(L1)
L5.append([0,0,0])
print("L5:",L5)
a.append(4)
print("L5:",L5)
```

out:

```
L2: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]]
L3: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
L3: [[1, 2, 3, 4], [4, 5, 6], [7, 8, 9]]
L4: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
L4: [[1, 2, 3, 4], [4, 5, 6], [7, 8, 9]]
L5: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]]
L5: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]]
```

